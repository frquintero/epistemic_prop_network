import json
import pytest


class NodeConfig:
    def __init__(self, name: str):
        self.name = name
        # simple template_id convention used by old builder
        self.template_id = name


class LayerConfig:
    def __init__(self, name: str, description: str = ""):
        self.name = name
        self.description = description
        self.nodes = []


class TemplateConfig:
    def __init__(self, node_epistemic_task: str = "", instructions=None):
        if instructions is None:
            instructions = []
        self.node_epistemic_task = node_epistemic_task
        self.input_context = ""
        self.template = ""
        self.instructions = instructions


def test_builder_templates_include_input_placeholders():
    """Ensure templates generated by the (legacy) builder include their input_context placeholders in `template`."""
    # Minimal 3-layer setup using small local types (replaces dependency on deprecated config_builder)
    layers = [
        LayerConfig(name='Input', description='input layer processing user query'),
        LayerConfig(name='Processing layer 2', description='Processing layer 2'),
        LayerConfig(name='Output', description='Output layer')
    ]

    # Nodes
    n1 = NodeConfig(name='reformulator')
    n2 = NodeConfig(name='semantic_node')
    n3 = NodeConfig(name='synthesis_node')
    layers[0].nodes = [n1]
    layers[1].nodes = [n2]
    layers[2].nodes = [n3]

    # Templates with only epistemic tasks (simulate user input)
    templates = {
        'reformulator': TemplateConfig(node_epistemic_task='Reformulate the question', instructions=['Output short question']),
        'semantic_node': TemplateConfig(node_epistemic_task='Analyze meaning', instructions=['300 words max']),
        'synthesis_node': TemplateConfig(node_epistemic_task='Synthesize analyses', instructions=['600 words max'])
    }

    # Simulate the builder's second-pass population logic
    expected_outputs = {
        'reformulator': 'reformulated_question',
        'semantic_node': 'semantic_analysis',
        'synthesis_node': 'comprehensive_synthesis'
    }

    for layer_idx, layer in enumerate(layers):
        for node in layer.nodes:
            template = templates[node.template_id]

            if layer_idx == 0:
                template.input_context = '{query}'
                if template.node_epistemic_task:
                    template.template = f"{template.node_epistemic_task}: {{query}}"
                else:
                    template.template = '{query}'
            else:
                prev_layer = layers[layer_idx - 1]
                prev_outputs = [expected_outputs[prev_node.template_id] for prev_node in prev_layer.nodes]
                if len(prev_outputs) == 1:
                    template.input_context = f"{{{prev_outputs[0]}}}"
                    if template.node_epistemic_task:
                        template.template = f"{template.node_epistemic_task}: {{{prev_outputs[0]}}}"
                    else:
                        template.template = f"{{{prev_outputs[0]}}}"
                else:
                    template.input_context = [f"{{{output}}}" for output in prev_outputs]
                    if template.node_epistemic_task:
                        joined = ' '.join([f'{{{o}}}' for o in prev_outputs])
                        template.template = f"{template.node_epistemic_task}: {joined}"
                    else:
                        template.template = ' '.join([f'{{{o}}}' for o in prev_outputs])

    # Assertions: each template string should contain its input_context placeholder
    for tid, t in templates.items():
        inp = t.input_context
        templ = t.template
        if isinstance(inp, list):
            for placeholder in inp:
                assert placeholder in templ, f"Template for {tid} missing placeholder {placeholder}"
        else:
            assert inp in templ, f"Template for {tid} missing placeholder {inp}"
